/**A type which matches all available formatters in this package. */
export type AnyFormatter = custom.BaseFormatter | DefaultFormatter | PropertyFormatter | TextFormatter | ObjectFormatter | ArrayFormatter | ObjectSwitchFormatter;
export declare namespace custom {
    /**All valid variable types in a JSON file. */
    type ValidJsonType = number | string | boolean | null | object | ValidJsonType[];
    /**## BaseFormatter `class`
     * The base of all formatters. This class can't be used directly, but needs to be extended from when creating custom formatters!
     */
    class BaseFormatter {
        /**The name of this variable. Used as key in objects. */
        name: string;
        /**Set this to `false` when this is a global variable or you don't want the key/name to be rendered. */
        showKey: boolean;
        constructor(name: string | null);
        /**Parse a variable trough this formatter! Returns a JSON string like `JSON.stringify()` */
        stringify(data: ValidJsonType): string;
    }
    /**## ObjectSwitchData `interface`
     * The data for a single "object switch" in the `ObjectSwitchFormatter`!
     */
    interface ObjectSwitchData {
        /**The key to match. */
        key: any;
        /**The value to match. */
        value: any;
        /**The formatter to use for the object when the key and value match! */
        formatter: ObjectFormatter;
    }
}
/**## DefaultFormatter `class`
 * You can use this formatter when you don't know the contents of the variable!
 *
 * It just uses the default `JSON.stringify` under the hood!
 */
export declare class DefaultFormatter extends custom.BaseFormatter {
    /**When enabled, objects & arrays will be rendered multiline instead of inline! */
    multiline: boolean;
    /**The space or indentation for this object/array. 4 spaces by default. */
    space: string;
    constructor(name: string | null, multiline: boolean, space?: string);
    stringify(data: custom.ValidJsonType): string;
}
/**## PropertyFormatter `class`
 * The formatter responsible for formatting `boolean`, `string`, `number` & `null` variables!
 */
export declare class PropertyFormatter extends custom.BaseFormatter {
    stringify(data: number | string | boolean | null): string;
}
/**## TextFormatter `class`
 * The formatter responsible for adding custom text between properties in an object!
 */
export declare class TextFormatter extends custom.BaseFormatter {
    /**The text to write on this row. */
    text: string;
    constructor(text?: string);
    stringify(): string;
}
/**## ObjectFormatter `class`
 * The formatter responsible for formatting `object` variables!
 */
export declare class ObjectFormatter extends custom.BaseFormatter {
    #private;
    /**When enabled, the object will be rendered multiline instead of inline! */
    multiline: boolean;
    /**A collection of all the child-formatters in this object. */
    children: custom.BaseFormatter[];
    /**When enabled, the object will still be rendered multiline when it's empty! */
    multilineWhenEmpty: boolean;
    /**The space or indentation for this object. 4 spaces by default. */
    space: string;
    constructor(name: string | null, multiline: boolean, children: custom.BaseFormatter[], multilineWhenEmpty?: boolean, space?: string);
    stringify(data: object): string;
}
/**## ArrayFormatter `class`
 * The formatter responsible for formatting `array` variables!
 */
export declare class ArrayFormatter extends custom.BaseFormatter {
    #private;
    /**When enabled, the array will be rendered multiline instead of inline! */
    multiline: boolean;
    /**The formatter that will be executed on all variables in the array. */
    property: custom.BaseFormatter;
    /**When enabled, the object will still be rendered multiline when it's empty! */
    multilineWhenEmpty: boolean;
    /**The space or indentation for this array. 4 spaces by default. */
    space: string;
    constructor(name: string | null, multiline: boolean, property: custom.BaseFormatter, multilineWhenEmpty?: boolean, space?: string);
    stringify(data: custom.ValidJsonType[]): string;
}
/**## ObjectSwitchFormatter `class`
 * Use this utility class to switch `ObjectFormatter`'s based on a `key` and `value` match in the object.
 *
 * This could be used in combination with an `ArrayFormatter` to allow different objects to exist in the same array!
 */
export declare class ObjectSwitchFormatter extends custom.BaseFormatter {
    /**A list of all available formatters to check for an object. */
    formatters: custom.ObjectSwitchData[];
    constructor(name: string | null, formatters: custom.ObjectSwitchData[]);
    stringify(data: object): string;
}
